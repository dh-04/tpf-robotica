// Class automatically generated by Dev-C++ New Class wizard

#include "GoToBaseGroup.h" // class's header file
#include "GarbageCleaner.h"
#include <math.h>

#define BASE_X -0.874047
#define TOLE 0.2
#define BASE_POSITION (BASE_X+TOLE)

#define PASSAGE_BEGIN_X -0.6
#define PASSAGE_LINE_Z 0.100174

#define LINE_MARK_X -0.626685

namespace behaviours {

// class constructor
GoToBaseGroup::GoToBaseGroup(WorldInfo * wi,robotapi::IRobot * robot, robotapi::IBattery * robotBatt, robotapi::IBattery * pcBatt, robotapi::IDifferentialWheels * wheels, std::vector<robotapi::IDistanceSensor*> & fss) : AbstractBehaviour("Go To Base Group")
{
	this->robotBattery = robotBatt;
	this->pcBattery = pcBatt;
	this->wi = wi;
	this->fss = &fss;
	this->wheels = wheels;
	
	this->robotBattery->setEmptyBias(3500);
	this->robotBattery->setFullBias(15000);
	behaviours::AbstractBehaviour * ab = new behaviours::FindLine( wi, wheels, fss );
	myBehaviours[0] = ab;

	ab = new behaviours::PositionInLine( wi, wheels, fss );
	myBehaviours[1] = ab;

	ab = new behaviours::GoToBase( wheels, fss );
	myBehaviours[2] = ab;
	
	ab = new behaviours::Recharge( robot, wheels, robotBatt, pcBatt, fss);
	myBehaviours[3] = ab;
}

// class destructor
GoToBaseGroup::~GoToBaseGroup()
{
	// insert your code here
}

void GoToBaseGroup::sense(){
//		this->setStimulusPresent();
	if ( this->robotBattery->isEmpty() || this->pcBattery->isEmpty() )
		this->setStimulusPresent();


        for (int j = 0; j < FLOOR_SENSORS; j++){
			printf("Floor sensor %d: %d\n", j, (*this->fss).at(j)->getValue() );
		}

}

int following = false;
bool beenOnMark = false;

void GoToBaseGroup::action(){
	if ( ! following ){
		beenOnMark = false;
		if ( !this->inLine() ){
		    this->myBehaviours[0]->action();
	    	printf("Going to line\n");
		    return;
		}

		if ( this->inLine() && !this->inPosition() ){
		    this->myBehaviours[1]->action();
	    	printf("On Line, Positioning...\n");
		    return;
		}
	}
	following = true;
//	if ( !this->inLine() && fabs( this->wheels->getOrientation() - PI/2 ) < ORIENTATION_TOLE ){
	double xpos = this->wheels->getPosition()->getX();
	if ( !this->inLine() ){
		if ( xpos < BASE_POSITION ){
	    	printf("Recharging\n");
			this->myBehaviours[3]->action();
		}
		following = false;
	}else{
		if( xpos < PASSAGE_BEGIN_X && this->onMark() && ! beenOnMark ){
			printf("On Mark!");
			beenOnMark = true;
			system("pause");
			this->wheels->setPosition(new utils::MyPoint(LINE_MARK_X,PASSAGE_LINE_Z));
		}
	    this->myBehaviours[2]->action();
	    printf("Following Line\n");
	}
    return;
}

bool GoToBaseGroup::onMark(){
	return (*this->fss).at(0)->getValue() < LINE_THRESHOLD &&
			(*this->fss).at(1)->getValue() < LINE_THRESHOLD &&
			(*this->fss).at(2)->getValue() < LINE_THRESHOLD;
}

bool GoToBaseGroup::inLine(){
	return (*this->fss).at(0)->getValue() < LINE_THRESHOLD ||
			(*this->fss).at(1)->getValue() < LINE_THRESHOLD ||
			(*this->fss).at(2)->getValue() < LINE_THRESHOLD;
}

bool GoToBaseGroup::inPosition(){
	double targetAngle = PI/2;
	if ( this->wheels->getPosition()->getY() < 0.06 )
	    targetAngle = PI;
	else if ( this->wheels->getPosition()->getY() > 0.15 )
	    	targetAngle = 0;

	return fabs( this->wheels->getOrientation() - targetAngle ) < ORIENTATION_TOLE;
}

} /* End of namespace behaviours */
