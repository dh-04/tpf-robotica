\section{Requerimientos}
\label{h_requerimientos}

\section{Ideas de implementaci\'on}
\label{h_ideas}

\subsection{Locomoci\'on}
\label{h_ideas_locomocion}

distintos tipos de locomocion que tuvimos en cuenta y porque elegimos este

\subsection{Sensado del entorno}
\label{h_ideas_sensado}

distintos tipos de sensores disponibles y porque elegimos estos

\subsection{Controlador}
\label{h_ideas_controlador}

distintas formas de diagramar la forma de control, que tipo de controladores necesitamos, en cuales pensamos, con cuales nos quedamos

\subsection{M\'etodo de recolecci\'on}
\label{h_ideas_recoleccion}

distintos metodos que se nos ocurrieron

\section{Actuadores}
\label{h_actuadores}

En nuestro caso, los motores son la principal forma en que el robot puede interactuar activamente con el ambiente que lo rodea.
Cada una de las tareas que deb\'iamos realizar requer\'ia de actuadores acordes.

Estas cuestiones son las que analizamos en este apartado.

\subsection{Motores de cont\'inua}
\label{h_actuadores_motorDC}

Para la tracci\'on principal de las ruedas necesitabamos motores que tuvieran el torque necesario para mover el robot, pero que pudieramos medir y
controlar la velocidad era la principal necesidad. Para esta tarea utilizamos motores de cont\'inua con caja reductora y encoder.
Con dos de estos motores logramos poder garantizar una velocidad determinada en las ruedas, controlar de la cantidad de movimiento en forma
independiente en cada rueda y entre otras cosas conocer la cantidad de las vueltas dadas por cada una de las ruedas.

\subsubsection{Caracter\'isticas}
\label{h_actuadores_motorDC_caracteristicas}

Los motores que elegimos son de la marca Ignis \footnote{http://www.ignis.com.ar} modelo \emph{MR-2FA} con caracter\'isticas expresadas en la tabla
\ref{hT_motorDC}, est\'an provistos de una caja reductora, poseen un encoder de $4$ estados por vuelta en el eje del motor y un sensor de de efecto
de campo para determinar una vuelta en la salida de la caja reductora.

La caja reductora provee una relaci\'on de $94$ vueltas del motor por cada $1$ vuelta del eje de salida de la caja.

En la figura \ref{hF_motorDC} mostramos las dimensiones exteriores del motor.

\begin{table}
	\begin{center}
		\begin{tabular}{|l|c|c|c|c|}
			\hline
			Caracter\'istica & Unidad & M\'inimo & Nominal & M\'aximo \\
			\hline
			Tensi\'on & V & 8 & 9 & 12 \\
			Corriente & A & 0.6 & 1.2 & 2.4 \\
			Velocidad & RPM & 1 & 60 & 60 \\
			Aceleraci\'on & $1/s^{2}$ & 0.1 & 0.1 & 0.5 \\
			Torque & kgf*cm & 0 & 1.2 & 6.4 \\
			\hline
		\end{tabular}
	\end{center}
	\caption{Caracter\'isticas del motor Ignis MR-2FA.}
	\label{hT_motorDC}
\end{table}

\begin{figure}[ht]
	\centering
	\includegraphics[scale=1]{MR2-FA.png}
	\caption{Vista lateral y frontal del motor Ignis MR-2FA.}
	\label{hF_motorDC}
\end{figure}

Una ventaja que encontramos en este modelo es que ya trae el encoder integrado aunque su resoluci\'on podr\'ia haber sido mayor.
Los encoders los explicamos m\'as en detalle en la secci\'on \ref{h_sensado_encoder}.

\subsubsection{Circuito de control}
\label{h_actuadores_motorDC_circuito}

Para alimentar y poder controlar los motores elegimos el driver \emph{L298} de la marca ST \footnote{http://www.st.com}.
Internamente tiene dos puentes H puenteables y puede soportar hasta $4 A$. Ideal para estos motores u otros que se elijan en el futuro.

La principal funci\'on del driver era proveer de la corriente y voltaje necesarios para el funcionamiento del motor, pero la configuraci\'on
del puente H nos dio la posibilidad de, con una l\'ogica simple, determinar el sentido de la corriente y potencia que recib\'ia el motor.

Este integrado admite el puenteo de la salida aumentando as\'i la corriente que pueda circular por \'el.
Para hacer esto, conectamos las salidas \emph{Out1} y \emph{Out4} por un lado y por el otro las salidas \emph{Out2} y \emph{Out3}.
De igual forma los pines de habilitaci\'on \emph{EnA} y \emph{EnB}, luego la entrada \emph{In1} con la \emph{In4} por un lado y
por el otro la \emph{In2} con la \emph{In3}.

\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.40]{L298.png}
	\caption{Diagrama interno del driver L298.}
	\label{hF_l298}
\end{figure}

De esta forma, se controla con s\'olo $3$ cables, uno de habilitaci\'on y otros $2$ de \emph{Input} que determinan
la polarizaci\'on de los transistores internos y por ende, el sentido de giro del motor.
En la tabla \ref{hT_l298} mostramos la tabla de verdad para los pines de control.
En la figura \ref{hF_l298} mostramos el diagrama interno del integrado.

\begin{table}
	\begin{center}
		\begin{tabular}{|c|c|c|c|}
			\hline
			Enable & Input $1$ & Input $2$ & Funci\'on \\
			\hline
			H & H & L & Sentido horario \\
			H & L & H & Sentido anti-horario \\
			H & L & L & Motor frenado \\
			H & H & H & Motor frenado \\
			L & X & X & Motor libre \\
			\hline
		\end{tabular}
	\end{center}
	\caption{Tabla de verdad para el control del driver \emph{L298}. Donde H es estado algo, L estado bajo y X cualquier estado.}
	\label{hT_l298}
\end{table}

Para determinar la potencia que recibir\'ia el motor usamos el m\'odulo de \emph{PWM} del microcontrolador, que explicamos m\'as en detalle en la
secci\'on \ref{h_controlador_micro_modulos}.
Variando el ancho del pulso sobre el pin de habilitaci\'on del driver determinamos la cantidad de tiempo que el motor recibe tensi\'on, lo cual
se traduce en la potencia que este tiene para realizar el movimiento.
Cuanto mayor es el tiempo en estado alto del pulso, mayor la potencia.

Para contrarrestar la corriente negativa en las salidas del driver usamos los diodos \emph{FR304} que cumplen con las especificaciones del driver
con $150$ns de tiempo de recuperaci\'on y una corriente de $3 A$.

El consumo del motor lo medimos mediante los pines de sensado en el driver, conectado a masa por una resistencia y al m\'odulo de \emph{ADC} del
microcontrolador, que explicamos en la secci\'on \ref{h_controlador_micro_modulos}.
Conociendo el valor de la resistencia y el valor leido por el m\'odulo de \emph{ADC}, pudimos determinar cuanta corriente que circulaba por la
resistencia y por ende la corriente consumida por el motor.

Para controlar la velocidad del motor usamos 1 de los 2 encoders que trae.
Conectados como entrada para el m\'odulo de \emph{Timer} del microcontrolador, en configuraci\'on de contador, que explicamos m\'as en detalle en la
secci\'on \ref{h_controlador_micro_modulos}.
Usando otro \emph{Timer} para tener una base de tiempo fija y con el valor del contador pudimos determinar y controlar la velocidad de las ruedas.

En la secci\'on \ref{h_placas_motorDC} explicamos el desarrollo de la placa controladora de estos motores.

\subsubsection{Rutinas de control}
\label{h_actuadores_motorDC_rutinas}

Desde el punto de vista del c\'odigo, tuvimos que desarrollar las rutinas necesarias para el manejo de los motores seg\'un las intrucciones del
controlador principal.

Configuramos a uno de los timers internos del microcontrolador para que genere una interrupci\'on cada $6.25$ms, la cual usamos para realizar
chequeos y ejercer control sobre el motor.
Verificamos el consumo del motor para evitar sobrecargar el circuito y los motores ante un posible atasco de las ruedas.
Tambi\'en actualizamos el acumulado de vueltas realizadas por el motor para la odometr\'ia.

Cada $200$ms, o sea $32$ interrupciones, tomamos la cantidad de cuentas del encoder, correjimos la velocidad de giro del motor ajustando el
ancho del pulso generado por el PWM.
Luego borramos el contador y esperamos otros $200$ms.

\subsection{Servo motores}
\label{h_actuadores_servo}

Para el movimiento de las partes del m\'odulo de recolecci\'on. una c\'amara con paneo y giro o un senor de ultrasonido colocado
en la parte superior haciendo las veces de radar, pensamos en el uso de servo motores.
La principal caracter\'istica de estos actuadores es que nosotros s\'olo debemos indicar el \'angulo al que queremos que este
el eje del motor y este se coloca autom\'aticamente.
El \'angulo de trabajo va desde $0^{\circ}$ a $180^{\circ}$ y algunos llegan hasta los $200^{\circ}$.

Aunque no fue implementado el ning\'un mecanismo que requiriera el uso de estos motores, explicamos en este apartado el trabajo realizado
en torno a este tipo de actuadores.
En la secci\'on \ref{h_placas_servos} explicamos el dise\~no de las placas que los controlan.

El servo de prueba que utilizamos para el desarrollo es el modelo \emph{HX5010} de la marca Hextronik \footnote{www.hextronik.com/}
con caracteristicas que expresamos en la tabla \ref{hT_hx5010}

\begin{table}
	\begin{center}
		\begin{tabular}{|c|c|c|}
			\hline
			Caracter\'istica & Unidad & Valor \\
			\hline
			Torque & kg & $6.5$ \\
			Velocidad & segundos/grado & $\frac{0.16}{60}$ \\
			Voltaje & V & $4.8$ a $6$ \\
			Delay m\'aximo & $\mu s$ & $4$ \\
			Dimensiones & $mm$ & 40x20x38 \\
			Peso & $g$ & $39$ \\
			\hline
		\end{tabular}
	\end{center}
	\caption{Caracter\'isticas del servo HX5010.}
	\label{hT_hx5010}
\end{table}

\subsubsection{Circuito de control}
\label{h_actuadores_servo_circuito}

La alimentaci\'on y consumo depende del modelo espec\'ifico, variando tambi\'en el torque que posee el servo.

No es necesario el uso de un driver para manejarlos, simplemente con la alimentaci\'on y una se\~nal con el \'angulo es suficiente.
La forma de comunicar el \'angulo var\'ia entre los distintos servos y fabricantes.
Hay servos anal\'ogicos y servos digitales.
En los primeros la posici\'on se determina mediante un voltaje que varia seg\'un cierto rango y si es digital, se setea mediante el ancho de
un pulso que tiene un tiempo m\'inimo y m\'aximo para mapear los \'angulos m\'inimo y m\'aximo respectivamente.

Dentro del modo de uso, podemos hacer que queden sueltos o que se queden fijos en cierta posici\'on indicando, de forma cont\'inua, el valor
del \'angulo requerido.
La frecuencia a la que se debe setear la posici\'on depende el modelo.

\subsubsection{Rutinas de control}
\label{h_actuadores_servo_rutinas}

Debido a que pensamos usar servos digitales y por lo menos \'ibamos a necesitar $3$ servos, necesitabamos contar con varios m\'odulos de PWM.
Como s\'olo dispon\'iamos de 1, decidimos realizar la misma funci\'on pero por software.

Usamos el timer de $16$bits del microcontrolador configurado con el clock interno como medida del tiempo para crear $5$ salidas con
pulsos que var\'ian el ancho en forma independiente cada una.
Definimos un ancho m\'inimo y m\'aximo, pudiendo configurar pasos intermedios de $1^{\circ}$ (aproximadamente $69.4\mu s$).

\section{Sensado}
\label{h_sensado}

En este apartado explicamos detalladamente cada uno de los sensores que utilizamos para realizar tanto las mediciones externas como las internas al robot.
Analizamos las ventajas de cada uno, problemas que encontramos y sus soluciones.

En la secci\'on \ref{h_placas_sensado} explicamos el dise\~no y construcci\'on de las placas que controlan todos los sensores del robot.

\subsection{Tel\'emetros infrarrojos}
\label{h_sensado_telemetros}

El principio de funcionamiento de estos sensores es mediante un haz de luz infrarroja que es emitido hacia el objetivo, el cual
es reflejado y captado a traves de un lente por un sensor de posici\'on relativa en el interior del sensor.
En base a esta medici\'on se calcula la distancia entre el sensor y el objeto reflectivo que se encuentra frente a \'el.

\subsubsection{Caracter\'isticas}
\label{h_sensado_telemetros_caracteristicas}

medidas, tiempo de muestreo, tipo de salida, rangos de distancia, rangos de voltaje, distancia vs voltaje

Los tel\'emetros infrarrojos que elegimos son de la marca Sharp \footnote{http://sharp-world.com/products/device}, modelo \emph{GP2D120}.
En la tabla \ref{hT_gp2d120} detallamos los valores caracter\'isticos del modelo.

Este tipo de sensores tienen un retardo de aproximadamente $43.1ms$ durante el cual la lectura que se realiza no es confiable y luego
las nuevas lecturas se hacen en ventanas de aproximadamente el mismo tiempo.
En la figura \ref{hF_gp2d120_pulse} mostramos el diagrama de tiempos.

\begin{table}[ht]
	\begin{center}
		\begin{tabular}{|l|c|c|}
			\hline
			Caracter\'istica & Unidad & Valor\\
			\hline
			Rango m\'aximo & $cm$ & 30 \\
			Rango m\'inimo & $cm$ & 4 \\
			Tensi\'on para la m\'axima distancia & $V$ & 1.95 \\
			Tensi\'on para la m\'inima distancia & $V$ & 2.55 \\
			Tensi\'on de alimentaci\'on & $V$ & 5 \\
			Consumo m\'aximo & $mA$ & 50 \\
			\hline
		\end{tabular}
	\end{center}
	\caption{Caracter\'isticas del sensor de distancia por ultrasonido SRF05.}
	\label{hT_gp2d120}
\end{table}

\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.25]{gp2d120_pulse.png}
	\caption{Diagrama de tiempos del sensor GP2D120.}
	\label{hF_gp2d120_pulse}
\end{figure}

\subsubsection{Circuito de control}
\label{h_sensado_telemetros_circuito}

alimentacion, conmutacion (transistor, estado de habilitacion: 0), conexion con el micro, salida del sensor, modulo ADC, muestreo, capacitor para alimentacion, circuito minimo (diagrama)

No necesit\'abamos un driver para manejar los tel\'emetros, pero decidimos usar un transistor para poder habilitarlos o no,
de otra manera el sensor estaba tomando mediciones continuamente provocando un consumo de bater\'ia innecesario.
De esta forma s\'olo se enciende cuando se va a utilizar.

El transistor que utilizamos es un conmutador y amplificador de uso general, el \emph{BC327} y por ser de tipo PNP se
exita con un estado bajo, por lo que la l\'ogica de conmitaci\'on est\'a negada.

El tipo de salida de este modelo de tel\'emetros es anal\'ogica y est\'an conectadas al m\'odulo \emph{ADC} del microcontrolador.
En la figura \ref{hF_gp2d120_distancia} mostramos la tabla de conversi\'on entre voltaje de salida y distancia al objeto, y en la figura
\ref{hF_gp2d120_apertura} mostramos el \'angulo de apertura de la zona de detecci\'on seg\'un la distancia al objetivo.

\begin{figure}[ht]
	\begin{minipage}[b]{0.5\linewidth}
		\centering
		\includegraphics[scale=0.25]{tel-VxL.png}
		\caption{Voltaje de salida seg\'un la distancia al objeto del tel\'emetro GP2D120.}
		\label{hF_gp2d120_distancia}
	\end{minipage}
	\begin{minipage}[b]{0.5\linewidth}
		\centering
		\includegraphics[scale=0.25]{tel-VxX.png}
		\caption{\'Angulo de apertura seg\'un la distancia del tel\'emetro GP2D120.}
		\label{hF_gp2d120_apertura}
	\end{minipage}
\end{figure}

\subsubsection{Rutinas de control}
\label{h_sensado_telemetros_rutinas}

Controlar los tel\'emetros es relativamente sencillo.
Usamos el timer de $16$bits del microcontrolador configurado con el clock interno para determinar el tiempo en el cual
deb\'iamos tomar las muestras con el ADC y simplemente realizamos un promedio entre ellas para obtener la distancia al objetivo.

Para hacer esto desarrollamos una peque\~na m\'aquina de estados que controla y maneja los tiempos para tomar las muestras que
explicamos m\'as en detalle en la secci\'on \ref{h_placas_sensado_codigo}.

\subsection{Sensor de distancia por ultrasonido}
\label{h_sensado_ultrasonido}

Estos sensores de distancia se basan en la velocidad del sonido para calcular la distancia al objetivo.
Genera un tren de $8$ pulsos ultras\'onicos y luego se espera como respuesta, el mismo tren de pulsos que deber\'ia haber rebotado contra el objetivo.
En base a la diferencia de tiempo entre la emisi\'on del tren de pulsos y la respuesta, se calcula la distancia a la que se encuentra el objetivo.

\subsubsection{Caracter\'isticas}
\label{h_sensado_ultrasonido_caracteristicas}

El sensor de distancia por ultrasonido que elegimos es el modelo \emph{SRF05} de la marca Devantech Ltd \footnote{http://www.robot-electronics.co.uk/}.
Esta versi\'on mejorada del modelo \emph{SRF04}, aumenta el rango de detecci\'on y mejora el modo de control y lectura de los datos, permitiendo
hacerlo mediante un \'unico pin.

La distancia medida mediante el tren de pulsos es codificada linealmente en el ancho de un pulso que var\'ia de $100\mu s$ a $25 ms$.
Si dentro del rango de detecci\'on no se encuentra ning\'un objeto, el pulso tendr\'a un ancho de $30ms$.

En la tabla \ref{hT_srf05} detallamos las caracter\'sticas del sensor \emph{SRF05} y en la figura \ref{hF_srf05} mostramos el haz ultras\'onico
del sensor.

\begin{table}[ht]
	\begin{center}
		\begin{tabular}{|l|c|c|}
			\hline
			Caracter\'istica & Unidad & Valor\\
			\hline
			Tensi\'on de alimentaci\'on & $V$ & 5 \\
			Corriente & $mA$ & 4 \\
			Frecuencia de trabajo & $KHz$ & 40 \\
			Rango m\'aximo & $cm$ & 400 \\
			Rango m\'inimo & $cm$ & 1.7 \\
			Duraci\'on m\'inima del pulso de disparo & $\mu s$ & 10 \\
			Duraci\'on del pulso eco de salida & $\mu s$& 100 - 25000 \\
			Tiempo m\'inimo de espera entre mediciones & $m s$ & 50 \\
			Dimensiones & $mm$ & 43x23x40 \\
			\hline
		\end{tabular}
	\end{center}
	\caption{Caracter\'isticas del sensor SRF05.}
	\label{hT_srf05}
\end{table}

\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.5]{srf05_beam.png}
	\caption{Haz ultras\'onico del sensor SRF05.}
	\label{hF_srf05}
\end{figure}

\subsubsection{Circuito de control}
\label{h_sensado_ultrasonido_circuito}

No necesitamos de un driver para manejar al sensor ya que lo conectamos directo a los $5v$ de la placa.
El pin de \emph{Mode} lo dejamos en estado bajo para indicar que debe funcionar bajo el nuevo modo y no en compatibilidad con el \emph{SRF04}.

En el pin de \emph{TRIGGER} s\'olo generamos un pulso de al menos $10\mu s$ para desencadenar en la lectura de la distancia al objetivo.
El sensor nos asegura que no generar\'a el pulso de respuesta hasta pasados los $700\mu s$ desde pasado el pulso de trigger.
En la figura \ref{hF_srf05_pulse} mostramos el diagrama de tiempos.

\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.25]{srf05_pulse.png}
	\caption{Diagrama de tiempos del sensor SRF05.}
	\label{hF_srf05_pulse}
\end{figure}

Para evitar que el rebote de otros sensores o sensados anteriores influya en la lectura, se debe esperar un m\'inimo de $50ms$ antes de
generar otro medici\'on.

\subsubsection{Rutinas de control}
\label{h_sensado_ultrasonido_rutinas}

Usamos uno de los pines con interrupci\'on externa en el que conectamos el pin de \emph{TRIGGER} y el timer de $16$bits del microcontrolador
configurado con el clock interno.

Para realizar la medici\'on, generamos un pulso de $15\mu s$ para asegurarnos el disparo del sensor y cambiamos el modo del pin a entrada con
interrupci\'on ante un flanco ascendente.
Cuando salta la interrupci\'on significa que comienza al pulso con la distancia codificada en su ancho, por lo que tomamos una muestra del
timer y configuramos al pin para que genere ahora una interrupci\'on ante un flanco descendente.
Cuando salte la pr\'oxima vez la interrupci\'on, ser\'a porque termino el pulso con la medici\'on, por lo que s\'olo debemos hacer la resta
entre el valor actual del timer y la muestra que tomamos al principio para conocer la distancia a la que se encuentra el objetivo.

Un tiempo obtenido mayor a los $25ms$ indica que no se detect\'o ning\'un objeto dentro del rango del sensor.

\subsection{Sensor reflectivo de piso}
\label{h_sensado_piso}

Estos sensores opticos reflectivos emiten luz infrarroja y captan el nivel de luz reflejada sobre la superf\'icie a sensar como muestramos
en la figura \ref{hF_cny70_diagrama}.
En la figura \ref{hF_cny70_dim} mostramos las dimensiones del sensor.
La intensidad de luz captada depende de la distancia al objetivo y del color y nivel de reflectividad de la superficie.
Es por esto que usamos estos sensores para identificar una l\'inea en el piso.

\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.25]{cny70_dim.png}
	\caption{Medidas en mil\'imetros del sensor CNY70.}
	\label{hF_cny70_dim}
\end{figure}

\subsubsection{Caracter\'isticas}
\label{h_sensado_piso_caracteristicas}

Los sensores que elegimos para son del modelo \emph{CNY70} de la marca Vishay Semiconductor \footnote{http://www.vishay.com/}.

El rango efectivo de sensado ronda los $3 mm$ de distancia aunque, con un incremento en la corriente que circula por el emisor
se puede llegar a una distancia mayor a la recomendada por el fabricante y que nos permita un uso m\'as acorde al proyecto.
El emisor soporta un pulso de hasta $3 A$ por un tiempo menor o igual a $10\mu s$.

En la figura \ref{hF_cny70_ID} mostramos la corriente que circula por el colector del fototransistor en base a la distancia al objeto medido.

\begin{figure}[ht]
	\begin{minipage}[b]{0.45\linewidth}
		\centering
		\includegraphics[scale=0.25]{cny70_diagrama.png}
		\caption{Principio de funcionamiento reflectivo del sensor CNY70.}
		\label{hF_cny70_diagrama}
	\end{minipage}
	\hspace{0.5cm}
	\begin{minipage}[b]{0.45\linewidth}
		\centering
		\includegraphics[scale=0.25]{cny70_IxD.png}
		\caption{Corriente en el colector seg\'un la distancia del sensor CNY70.}
		\label{hF_cny70_ID}
	\end{minipage}
\end{figure}

\subsubsection{Circuito de control}
\label{h_sensado_piso_circuito}

De igual forma que en los tel\'emetros utilizamos un transistor como habilitaci\'on de la tensi\'on de alimentaci\'on en el sensor.
Esto nos dio la posibilidad de encenderlo y apagarlo a la hora de tomar las muestras de la luz reflejada por piso o la l\'inea.
Nuevamente la l\'ogica de habilitaci\'on es invertida por tratarse de un transistor \emph{BC327}.

Agragamos una resistencia para limitar la corriente que circulaba por el emisor y otra como pull-up en el emisor del fototransistor
que a su vez, conectamos al m\'odulo de \emph{ADC} del microcontrolador para efectuar las mediciones.

\subsubsection{Rutinas de control}
\label{h_sensado_piso_rutinas}

El c\'odigo que desarrollamos para obtener las muestras de estos sensores es sencillo, simplemente debemos habilitar el
transistor que alimenta al sensor con un estado l\'ogico bajo, tomar al menos $4$ muestras y promediarlas para tener un
valor adecuado del nivel de luz reflejado por la superficie.
Deshabilitamos el sensor y enviamos el valor.

Debido al circuito que armamos con un nivel alto de reflexi\'on leemos un valor bajo en el conversor anal\'ogico digital y
con un nivel bajo de luz, un valor alto.

\subsection{Encoders}
\label{h_sensado_encoder}

Los encoders son sensores que convierten una posici\'on lineal o angular en se\~nal el\'ectrica o pulsos.
Pueden determinar una posici\'on de forma absoluta o simplemente informar que hubo un movimiento.
El m\'etodo de sensado y la resoluci\'on del \'angulo de giro que detectan var\'ia seg\'un el modelo.

\subsubsection{Caracter\'isticas}
\label{h_sensado_encoder_caracteristicas}

Los motores \emph{MR-2FA} tienen encoders de cuadratura conectados al eje, previo a la caja reductora.
Estos encoders son de tipo fotoel\'ectricos, estan dispuestos a $135^{\circ}$ uno del otro y marcan $4$ estados por
cada vuelta del motor.
Estan colocados as\'i para poder conocer el sentido de giro midiendo la secuencia de estados de cada encoder.
Adicionalmente el motor cuenta con un sensor de efecto Hall el cual nos permite detectar una revoluci\'on completa
en el eje de salida de la caja reductora.

Nosotros como conocemos el sentido de giro del motor, pues lo determinamos con el puente H, necesitamos s\'olo
uno de los dos encoders para conocer y controlar la velocidad a la que gira el rotor del motor.

A la tensi\'on m\'axima los motores superan a las 320 cuentas por segundo, el m\'inimo y m\'aximo recomendables
son, para que podamos mantener un giro constante, $60$ y $300$ cuentas por segundo respectivamente.
Estos c\'alculos son usando uno de los dos fototransistores del encoder.

Dependiendo el tama\~no de las ruedas ser\'a la velocidad de final del robot.
La relacio\'on de caja de $94:1$ del motor.

\subsubsection{Circuito de control}
\label{h_sensado_encoder_circuito}

Conectamos una resistencia pull-up a $5V$ para la salida de sensado de los fototransistores y del sensor de efecto
Hall.
Tambi\'en incluimos un switch doble inversor para elegir cu\'al de los dos encoders usar.
El punto com\'un del switch est\'a conectado al pin de entrada de clock externo de uno de los Timers del
microcontrolador.

La alimentaci\'on de los encoders es directa y permanecen encendidos en todo momento.

\subsubsection{Rutinas de control}
\label{h_sensado_encoder_rutinas}

Como explicamos en la secci\'on \ref{h_actuadores_motorDC_rutinas}, en cada interrupci\'on del actualizamos
el hist\'orico de cuentas del motor adicionando o restando el \'ultimo valor del contador.

Tambi\'en comparamos contra las cuentas esperadas por intervalo de tiempo que fueron determinadas desde el controlador
principal para poder determinar si debemos incrementar o disminuir la potencia del motor y por ende la velocidad de las ruedas.

\subsection{Sensado de la bateria}
\label{h_sensado_bateria}

El sensado del nivel de tensi\'on en la bater\'ia lo hacemos mediante un divisor de tensi\'on entre los polos de la bater\'ia.
La salida del divisor es sensada de igual forma que los otros sensores, mediante el m\'odulo de \emph{ADC} del microcontrolador.
En la figura \ref{hF_bateria_diagrama} mostramos el diagrama del divisor de tensi\'on.

\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.35]{bateria.png}
	\caption{Divisor de tensi\'on para el sensado de la bater\'ia.}
	\label{hF_bateria_diagrama}
\end{figure}

En la tabla \ref{hT_bateria_divT} mostramos las posibles tensiones en la bater\'ia y la tensi\'on de salida en el divisor.
Tambi\'en incluimos el valor aproximado para el ADC con tensi\'on de referencia a $5V$ que leer\'ia la salida del divisor.
El rango de voltajes que analizamos es tienendo en cuenta la posibilidad de efectuar mediciones durante la carga de la bater\'ia
y sabiendo que con una tensi\'on menor a $5 V$ la l\'ogica del prototipo que construimos comenzar\'ia a fallar.

\begin{table}[ht]
	\begin{center}
		\begin{tabular}{|c|c|c|c|}
			\hline
			Bater\'ia ($V$) & Salida ($V$) & Valor en el ADC \\
			\hline
			16 & 4.327 & 886 \\
			15 & 4.057 & 831 \\
			14 & 3.786 & 776 \\
			13 & 3.516 & 720 \\
			12 & 3.245 & 665 \\
			11 & 2.975 & 609 \\
			10 & 2.704 & 554 \\
			 9 & 2.434 & 499 \\
			 8 & 2.163 & 443 \\
			 7 & 1.893 & 388 \\
			 6 & 1.623 & 332 \\
			 5 & 1.352 & 277 \\
			\hline
		\end{tabular}
	\end{center}
	\caption{Tensi\'on de la bater\'ia y la tensi\'on de salida en el divisor.}
	\label{hT_bateria_divT}
\end{table}

La conexi\'on es simple, los cables de entrada del divisor los conectamos a los polos de la bater\'ia y la salida al ADC.
Luego s\'olo debemos realizar las lecturas en el ADC y promediarlas para poder realizar los c\'alculos de la tensi\'on en la bater\'ia.

\subsection{Consumo del motor}
\label{h_sensado_consumo}

El consumo de los motores de corriente cont\'inua lo medimos leyendo el pin de sensado que se encuentra en el puente H que alimenta al motor.
Lo que medimos con el m\'odulo de \emph{ADC} del microcontrolador es la tensi\'on en este pin.
Esta depende de la ca\'ida de tensi\'on en la resistencia conectada a masa y de la corriente que circula por el motor.
Conociendo el valor de la resistencia podemos calcular el consumo del motor.
En la tabla \ref{hT_consumo} comparamos el consumo en el motor, el voltaje sensado y la lectura en el ADC.

\begin{table}[ht]
	\begin{center}
		\begin{tabular}{|c|c|c|c|}
			\hline
			Tensi\'on ($V$) & Consumo ($A$) & Valor en el ADC \\
			\hline
			$0$ & $0$ & $0$ \\
			$0.09$ & $0.19$ & $18$ \\
			$0.18$ & $0.38$ & $36$ \\
			$0.27$ & $0.57$ & $55$ \\
			$0.36$ & $0.76$ & $73$ \\
			$0.45$ & $0.95$ & $92$ \\
			$0.54$ & $1.14$ & $110$ \\
			$0.63$ & $1.34$ & $129$ \\
			$0.72$ & $1.53$ & $147$ \\
			$0.81$ & $1.72$ & $165$ \\
			$0.90$ & $1.91$ & $184$ \\
			$0.99$ & $2.10$ & $202$ \\
			$1.08$ & $2.29$ & $221$ \\
			$1.17$ & $2.48$ & $239$ \\
			\hline
		\end{tabular}
	\end{center}
	\caption{Tabla comparativa para el consumo del motor.}
	\label{hT_consumo}
\end{table}

\subsubsection{Pulsador u otro dispositivo disparador}
\label{h_sensado_pulsador}

Ademas de los sensores que describimos, pensamos que nos podr\'ian hacer falta pulsadores para controlar funciones
simples por ejemplo saber cuando una parte de alg\'un mecanismo llega a cierto punto o detectar finales de carrera
de un servo o sin fin.
Tambi\'en pueden ser otro tipo de sensores que generen un cambio de estado en el pin de sensado que se conecta al
microcontrolador.

Agregamos la posibilidad de usarlos en las distintas placas como explicamos en detalle en las secciones
\ref{h_placas_sensado} y \ref{h_placas_servos}.

\subsubsection{Rutinas de control}
\label{h_sensado_pulsador_rutinas}

La lectura en el estado de los pulsadores puede ser bajo demanda con solo leer el estado del pin en el que estan
conectados o puede ser ante una interrupci\'on por cambio de estado.
Estas cuestiones las tuvimos en cuenta a la hora de dise\~nar las placas.

\section{Controladores}
\label{h_controlador}

Todas las funciones del robot las deb\'iamos controlar mediante alg\'un tipo de dispositivo.
Decidimos utilizar una netbook y microcontroladores para esta tarea.
Estas cuestiones son las que explicamos en este cap\'itulo.

\subsection{Netbook}
\label{h_controlador_netbook}

modelo, marca, caracteristicas, para que se usa, sistema operativo y lenguaje de programacion

\subsection{Microcontrolador}
\label{h_controlador_micro}

Para el control de la velocidad de los motores, lectura de los encoders y los sensores de distancia usamos un
microcontrolador.
Nuestro dise\~no contempl\'o la existancia de varios m\'odulos con una o pocas funciones simples que se comunicaran
entre ellos y con el controlador principal, en nuestro prototipo la netbook.
La raz\'on por la cual lo armamos as\'i fue para simplificar cada placa controladora a nivel software y hardware.

Explicamos la comunicaci\'on entre los distintos controladores en la secci\'on \ref{h_comm}.

\subsubsection{Caracter\'isticas}
\label{h_controlador_micro_caracteristicas}

El microcontrolador que elegimos para realizar las tareas de control, configucari\'on y comunicaci\'on a bajo nivel
es el \emph{PIC16F88} de Microchip \footnote{http://www.microchip.com/}.
Cuenta con una arquitectura de memoria del tipo Hardvard, con una memoria \emph{FLASH} para 4096 instrucciones de
programa, una memoria \emph{RAM} de 368 bytes y una memoria \emph{EEPROM} de 256 bytes.
Tiene un set de instrucciones b\'asicas reducido y todas con el mismo tiempo de ejecuci\'on.
En este apartado nombramos algunos de los principales perif\'ericos incluidos en el microcontrolador y la utilidad
dentro del proyecto que encontramos para ellos.
Utilizamos con un cristal externo de 20MHz como clock.

\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.20]{pic16f88.png}
	\caption{Diagrama del microcontrolador PIC16F88.}
	\label{hF_pic16f88_diagrama}
\end{figure}

El microcontrolador tiene 2 puertos de 8 entradas y salidas cada uno de tipo TTL y CMOS.
Como mostramos en la figura \ref{hF_pic16f88_diagrama} cada pin se encuentra multiplexado con uno o m\'as perif\'ericos internos.

\subsubsection{M\'odulos internos}
\label{h_controlador_micro_modulos}

Internamente el microcontrolador tiene una serie de perif\'ericos que proveen de funciones extras y que utilizamos para lograr
cumplir con las necesidades de nuestro proyecto.
En la figura \ref{hF_pic16f88_modulos} mostramos los distintos m\'odulos internos del microcontrolador.

\begin{figure}[b]
	\centering
	\includegraphics[scale=0.35]{pic16f88_modulos.png}
	\caption{M\'odulos internos del microcontrolador PIC16F88.}
	\label{hF_pic16f88_modulos}
\end{figure}

Cuenta con $3$ timers, $2$ de $8$bits (\emph{TIMER0} y \emph{TIMER2}) y $1$ de $16$bits (\emph{TIMER1}).
Podemos configurarlos para que tomen al clock del microcontrolador o que tomen una fuente externa de clock.
Tambi\'en podemos aplicarles demultiplicadores que generan un clock de menor frecuencia al que se usa como entrada.
Pueden ser etapas previas o posteriores al timer y nos dan gran flexibilidad de uso.

El \emph{TIMER0} lo utilizamos para hacer control del tiempo en nuestros c\'odigos.
Conectados con el clock principal y configurados para que generen una interrupci\'on al hacer overflow,
obtenemos una buena medida del paso del tiempo.

El \emph{TIMER1} configurado como fuente externa a la salida del encoder, lo usamos como contador de pasos para medir la
velocidad del motor.
Tambi\'en lo usamos como medici\'on del tiempo para hacer las lecturas de los sensores.
Elegimos a este timer ya que al ser de $16$bits posee un mayor rango de valores y por lo tanto, pod\'iamos medir un mayor lapso
de tiempo o cuentas del encoder en cada caso.

El \emph{TIMER2} lo usamos en conjunto con el m\'odulo de \emph{PWM} para determinar el ancho del pulso que habilita al puente H
que provee de energ\'ia a los motores.

El m\'odulo conversor anal\'ogico digital nos dio la posibilidad de medir tensiones anal\'ogicas como por ejemplo
las salidas de los sensores, tensi\'on en la bateria o el consumo de los motores.
Tiene $7$ canales o pines distintos y podemos configurarlo para que genere un valor de $8$ o $10$bits.
Tambi\'en podemos determinar si se debe usar el valor de \emph{Vcc} y \emph{GND} como referencia o podemos proveer
de forma externa de los voltajes de referencia para generar un rango de voltajes diferente y aumentar o disminuir
as\'i la resoluci\'on del conversor.

El m\'odulo de \emph{PWM} nos provee la posibilidad de generar pulsos cont\'inuos de un ancho determinado.
En nuestro proyecto lo utilizamos como habilitaci\'on del puente H que alimenta a los motores variando as\'i la
potencia y por lo tanto, la velocidad final de las ruedas.
Se utiliza en conjunto con el \emph{TIMER2} seteando el prescaler y postscaler para determinar el ancho del
estado alto y del estado bajo de los pulsos.

Gracias al m\'odulo de \emph{AUSART} podemos realizar la comuinicaci\'on entre los distintos microcontroladores por hardware.
Este perif\'erico nos provee una conmunicaci\'on sincr\'onica o asincr\'onica dependiendo de la configuraci\'on.
Creamos la red de \emph{Daisy Chain} sobre el protocolo de RS-232.

GIO
EEPROM
CCP
SSP





\subsubsection{Programaci\'on del firmware}
\label{h_controlador_micro_programacion}

pines de programacion, icd2, IDE, lenguaje, version

\section{Comunicaci\'on}
\label{h_comm}

porque necesitamos comunicar los modulos, que necesidades hay, nivel de uso

\subsection{Conectividad entre m\'odulos}
\label{h_comm_conectividad}

daisy chain, diagrama, montado sobre rs232, control de errores

\subsection{Protocolo de comunicaci\'on}
\label{h_comm_protocolo}

caracteristicas necesarias en el protocolo, porque es importante, cosas que tuvimos en cuenta y decisiones, control de errores

\subsubsection{Caracter\'isticas b\'asicas}
\label{h_comm_protocolo_caracteristicas}

formado por paquetes, formato basico del paquete (header), control de errores

\subsubsection{Comandos comunes}
\label{h_comm_protocolo_comandosComunes}

contelo o listado de comandos comunes (en detalle o se van a un apendice) - son pocos.

\subsubsection{Comandos espec\'ificos}
\label{h_comm_protocolo_comandosEspecificos}

contelo o listado de comandos especificos segun el tipo de placa (referencia a un apendice con cada uno explicado)

\subsubsection{Estad\'isticas}
\label{h_comm_protocolo_estadisticas}

analisis de paquetes por segundo, bytes de datos vs bytes de header, retransmisiones, etc

\section{Placas controladoras}
\label{h_placas}

porque tuvimos que diseñar nuestras propias placas, cosas que tuvimos en cuenta y decisiones tomadas, codigos fuente a los apendices

\subsection{Placa gen\'erica}
\label{h_placas_generica}

funcion de una placa generica, porque fue armada, para que sirve

\subsubsection{Caracter\'isticas principales}
\label{h_placas_generica_caracteristicas}

testeo de nuevos modulos, testeo de la programacion, snifear la comunicacion, futuras expansiones

\subsubsection{M\'odulo de comunicaci\'on}
\label{h_placas_generica_comm}

explicacion de la comunicacion, igual en todas, switch de configuracion, pines, fichas, nodos en la cadena, cables pc-placa y placa-placa, max232

\subsubsection{Alimentaci\'on de la placa}
\label{h_placas_generica_alimentacion}

tension para la alimentacion, circuito de la fuente, consumo maximo, voltaje minimo de alimentacion, alimentacion de 5V directos

\subsubsection{Configuraci\'on}
\label{h_placas_generica_config}

configuracion minima de la placa, leds, comunicacion, header de programacion

\subsubsection{Esquem\'atico}
\label{h_placas_generica_esquematicos}

esquematicos de la placa

\subsubsection{Circuito}
\label{h_placas_generica_circuito}

circuito de la placa

\subsubsection{C\'odigo b\'asico}
\label{h_placas_generica_codigo}

explicacion de lo minimo que deberia tener para ser parte de la cadena de comunicacion

\subsubsection{Posibles extensiones}
\label{h_placas_generica_extensiones}

posibles extensiones a futuro de la placa - nuevos modulos de testeo o control o lectura muy basica de señales, pasar a montaje superficial los componentes, hacerla mas chica

\subsection{Placa controladora de motores DC}
\label{h_placas_motorDC}

funcion de una placa controladora de motorDC, porque fue armada, para que sirve, porque hay 2, porque no esta en una sola

\subsubsection{Caracter\'isticas principales}
\label{h_placas_motorDC_caracteristicas}

principio de funcionamiento, como logra controlar la velocidad, como logra ser parte de la cadena, como logra sensar el consumo, controlar el motor, puente H, diodos, leds, VREF

\subsubsection{M\'odulo de comunicaci\'on}
\label{h_placas_motorDC_comm}

se explico en el modulo generico, se agregan los comandos especificos y se puede explicar como se obtiene la informacion para dar las respuestas

\subsubsection{Alimentaci\'on de la placa}
\label{h_placas_motorDC_alimentacion}

se explico en el modulo generico, tension para la alimentacion para los motores, necesidad de masa unica como referencia, consumo aproximado de los motores

\subsubsection{Configuraci\'on}
\label{h_placas_motorDC_config}

configuracion de la placa, leds, comunicacion, header de programacion, switch de seleccion de encoder

\subsubsection{Esquem\'atico}
\label{h_placas_motorDC_esquematico}

esquematicos de la placa

\subsubsection{Circuito}
\label{h_placas_motorDC_circuito}

circuito de la placa

\subsubsection{C\'odigo b\'asico}
\label{h_placas_motorDC_codigo}

explicacion de lo minimo que deberia tener para ser parte de la cadena de comunicacion, sensado y control de la velocidad de los motores

\subsubsection{Posibles extensiones}
\label{h_placas_motorDC_extensiones}

unificar en una placa el control de mas de un motor, pasar a montaje superficial los componentes, hacerla mas chica

\subsection{Placas de sensado}
\label{h_placas_sensado}

funcion de una placa de sensado, porque fue armada, para que sirve, que tipo de sensores puedo conectar, cuales son las posibles configuraciones, diferencias, sensado de la bateria

\subsubsection{Caracter\'isticas principales}
\label{h_placas_sensado_caracteristicas}

principio de funcionamiento, como logra tomar las muestras de los sensores, como logra ser parte de la cadena, seteo de los tipos de sensores

\subsubsection{M\'odulo de comunicaci\'on}
\label{h_placas_sensado_comm}

se explico en el modulo generico, se agregan los comandos especificos y se puede explicar como se obtiene la informacion para dar las respuestas

\subsubsection{Alimentaci\'on de la placa}
\label{h_placas_sensado_alimentacion}

se explico en el modulo generico

\subsubsection{Configuraci\'on}
\label{h_placas_sensado_config}

configuracion de la placa, comunicacion, header de programacion

\subsubsection{Esquem\'atico}
\label{h_placas_sensado_esquematico}

esquematicos de la placa

\subsubsection{Circuito}
\label{h_placas_sensado_circuito}

circuito de la placa

\subsubsection{C\'odigo b\'asico}
\label{h_placas_sensado_codigo}

explicacion de lo minimo que deberia tener para ser parte de la cadena de comunicacion y sensado de los distintos perifericos

\subsubsection{Posibles extensiones}
\label{h_placas_sensado_extensiones}

uso de componentes como resistencias variables para regular la alimentacion de los sensores de piso y resistencias pull-up, pasar a montaje superficial los componentes, hacerla mas chica

\subsection{Placa controladora de servo motores}
\label{h_placas_servos}

funcion de una placa controladora de servos, porque no fue armada, para que se penso, alguna otra opcion de conexion, pines libres

\subsubsection{Caracter\'isticas principales}
\label{h_placas_servos_caracteristicas}

principio de funcionamiento, como logra generar varios pwm por software, como logra ser parte de la cadena

\subsubsection{M\'odulo de comunicaci\'on}
\label{h_placas_servos_comm}

se explico en el modulo generico, se agregan los comandos especificos y se puede explicar como se obtiene la informacion para dar las respuestas

\subsubsection{Alimentaci\'on de la placa}
\label{h_placas_servos_alimentacion}

se explico en el modulo generico, con modificaciones que permiten que circule una mayor cantidad de corriente para alimentar a los servos.

\subsubsection{Configuraci\'on}
\label{h_placas_servos_config}

configuracion de la placa, comunicacion, header de programacion

\subsubsection{Esquem\'atico}
\label{h_placas_servos_esquematico}

esquematicos de la placa

\subsubsection{Circuito}
\label{h_placas_servos_circuito}

circuito de la placa

\subsubsection{C\'odigo b\'asico}
\label{h_placas_servos_codigo}

explicacion de lo minimo que deberia tener para ser parte de la cadena de comunicacion y control de los servos

\subsubsection{Posibles extensiones}
\label{h_placas_servos_extensiones}

uso de componentes como resistencias variables para regular la alimentacion de los sensores de piso y resistencias pull-up, pasar a montaje superficial los componentes, hacerla mas chica

\section{Armado del prototipo}
\label{h_prototipo}

\subsection{Dise\~no}
\label{h_prototipo_diseno}

\subsection{Caracter\'isticas}
\label{h_prototipo_caracteristicas}

con las ruedas de 10cm y teniendo en cuenta que el motor gira a unas 300 cuentas/segundo (usando un solo sensor en el encoder) llegamos a 50 cm/s de velocidad

\subsection{Desarme}
\label{h_prototipo_desarme}

\subsection{Costo y proveedores}
\label{h_prototipo_costo}
